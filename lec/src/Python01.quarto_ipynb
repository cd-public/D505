{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Machine Learning in Python\"\n",
        "subtitle: \"Applied Machine Learning\"\n",
        "author: \"Calvin\"\n",
        "  \n",
        "jupyter: python3\n",
        "\n",
        "execute:\n",
        "    echo: true\n",
        "    cache: true\n",
        "    freeze: true  # never re-render during project render\n",
        "---\n",
        "\n",
        "\n",
        "## Prerequisite\n",
        "\n",
        "- I assume a Python/VS Code/Quarto workflow.\n",
        "    - Review [this document](Python00.html)\n",
        "- I assume familiarity with Machine Learning in R\n",
        "    - Review [these slides](Session01.html)\n",
        "\n",
        "\n",
        "## Agenda\n",
        "\n",
        "1.  Python Overview\n",
        "2.  Review of Regression\n",
        "3.  Classification\n",
        "4.  Basic Feature Engineering\n",
        "\n",
        "## Quarto\n",
        "\n",
        "-   I switch from a R backend to a Python backend.\n",
        "-   I add the following below my title in my .qmd header:\n",
        "    -   `jupyter: python3`\n",
        "\n",
        "```yml         \n",
        "title: \"Machine Learning in Python\"\n",
        "subtitle: \"Applied Machine Learning\"\n",
        "author: \"Calvin\"\n",
        "  \n",
        "jupyter: python3\n",
        "```\n",
        "\n",
        "## Pip\n",
        "\n",
        "-   In Python, we can typically install packages via `pip`\n",
        "-   It is more typical to use `pip` at commandline.\n",
        "\n",
        "``` bash\n",
        "python -m pip install sampleproject\n",
        "```\n",
        "\n",
        "-   Here is a 'clean' way to do so from within the Python\n"
      ],
      "id": "684511c8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import subprocess  # A base package we need to install other packages\n",
        "import sys         # A base package we need to install other packages\n",
        "install = lambda package : subprocess.check_call([sys.executable, \n",
        "                                                  '-m', \n",
        "                                                  'pip', \n",
        "                                                  'install', \n",
        "                                                  package])"
      ],
      "id": "62df27ad",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Packages\n",
        "\n",
        "-   I'll build a list of packages then install them via a loop.\n",
        "    -   Some (numpy, matplotlib) required for Quarto.\n"
      ],
      "id": "9555642f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "python_data_stack = [\"numpy\", \"pandas\", \"matplotlib\", \"seaborn\"]\n",
        "r_data_stack = ['pyreadr', 'statsmodels']\n",
        "packages = python_data_stack + r_data_stack + [\"scikit-learn\"]\n",
        "\n",
        "_ = [install(package) for package in packages]"
      ],
      "id": "f521921b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   I use `_ =` to discard the result of the process.\n",
        "    -   This ignores errors - remove to debug.\n",
        "\n",
        "## Import\n",
        "\n",
        "-   Python packages use `import` rather than `library()`\n",
        "-   Python base data stack"
      ],
      "id": "a77fc58e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns"
      ],
      "id": "c9be10a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   R & statistics"
      ],
      "id": "b5132653"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pyreadr\n",
        "import statsmodels.api as sm\n",
        "import statsmodels.formula.api as smf"
      ],
      "id": "84944dab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## ML Library\n",
        "-   There are 3.5 Python ML libraries that matter\n",
        "    -   Scikit-learn, mainline ML\n",
        "    -   Torch, deep learning\n",
        "    -   Tensorflow, deep learning\n",
        "    -   PySpark MLlib, MLOps"
      ],
      "id": "2bf8ec06"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Common to include parts of, not all of, sklearn\n",
        "from sklearn.linear_model import LinearRegression\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay"
      ],
      "id": "d474f877",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Many packages\n",
        "-   There's a lot of imports here, we could cut back but...\n",
        "-   We would typical use only `sklearn` not `stats_models`\n",
        "    -   SM=statisical learning, SK=machine learning\n",
        "    -   Use SM for equivalence with R.\n",
        "-   Typically use the module name as a function's prefix.\n",
        "    -   This resolves name collisions, like `dplyr` and `stats`\n",
        "\n",
        "    ``` r\n",
        "    ✖ dplyr::filter() masks stats::filter()\n",
        "    ✖ dplyr::lag()    masks stats::lag()\n",
        "    ```\n",
        "\n",
        "## Setup\n",
        "\n",
        "-   We will use `pyreadr` to read in an R dataset.\n",
        "    -   This is atypical but not difficult.\n"
      ],
      "id": "4c8bc1d5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "url = 'https://cd-public.github.io/D505/dat/'\n",
        "rds = 'wine.rds'\n",
        "pyreadr.download_file(url + rds, rds) \n",
        "wine = pyreadr.read_r(rds)[None]      \n",
        "wine.dropna(subset=['points','price'])\n",
        "str(wine.info()) # string for slide formatting"
      ],
      "id": "953ba2c7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Review of Regression\n",
        "\n",
        "## Single Variable\n",
        "\n",
        "-   Pick the poshest province.\n"
      ],
      "id": "f98b1f16"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "wine['bordeaux'] = wine['province'] == 'Bordeaux'\n",
        "wine.head(2)"
      ],
      "id": "ed5d3931",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Regress\n",
        "\n",
        "-   Take a quick regression model over the wine.\n"
      ],
      "id": "75ba3bb1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "m1 = sm.OLS(wine['points'], wine['price']).fit()\n",
        "m1.summary()"
      ],
      "id": "9648c7cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Sklearn\n",
        "\n",
        "-   I'm much fonder of `sklearn` for this sort of thing.\n"
      ],
      "id": "419cf845"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "s1 = LinearRegression().fit(wine[['points']],wine['price'])\n",
        "f'Intercept: {s1.intercept_}, Coefficients: {s1.coef_}'"
      ],
      "id": "8d43357e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Let's draw it\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width='50%'}\n",
        "-   Python ggplot is `plotnine`\n",
        "-   I prefer Seaborn (`sns`)\n",
        "-   Also: `matplotlib`\n",
        "-   Also: `plotly`\n",
        ":::\n",
        "\n",
        "::: {.column width='50%'}"
      ],
      "id": "edf2d218"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.lmplot(x='points', y='price', \n",
        "           data=wine, scatter=True, \n",
        "           x_bins=range(80,101))"
      ],
      "id": "1bbb9b1a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "## Multiple regression\n",
        "\n",
        "-   We can literally use the exact same formula in `smf`\n",
        "-   I am unaccustomed to doing multiple regressions without interaction.\n",
        "    -   Moving on.\n"
      ],
      "id": "6d5a45f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "m2 = smf.ols('price ~ points + bordeaux', data=wine).fit()\n",
        "m2.summary()"
      ],
      "id": "0fb392a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## How about with an interaction?\n"
      ],
      "id": "99df81d1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "m3 = smf.ols('price ~ points * bordeaux', data=wine).fit()\n",
        "m3.summary()"
      ],
      "id": "b82398e6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Sklearinteraction\n",
        "\n",
        "-   `sklearn` defaults to multiple regression.\n"
      ],
      "id": "ab5a56b8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "wine['points_bordeaux'] = wine['points'] * wine['bordeaux']\n",
        "\n",
        "s3 = LinearRegression().fit(wine[['points','bordeaux']],\n",
        "                            wine['price'])\n",
        "f'Intercept: {s3.intercept_}, Coefficients: {s3.coef_}'"
      ],
      "id": "fd01dfda",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Let's draw it\n"
      ],
      "id": "12220ac8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.lmplot(x='points', y='price', \n",
        "           data=wine, scatter=True, \n",
        "           x_bins=range(80,101), hue='bordeaux')"
      ],
      "id": "9d265c75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Moving to an ML framework\n",
        "\n",
        "## Split sample using Sklearn\n",
        "-   Vs R, with a proliferation of libraries, Python ML is concentrated.\n",
        "-   There are a few main libraries, `Sklearn` the first and most popular\n",
        "-   So modelling and partitioning are all in `sklearn`, vs `stats` and `caret`\n"
      ],
      "id": "658d3cfc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "random_seed = 505\n",
        "train, test = train_test_split(wine, random_state=random_seed)\n",
        "print(test.head())"
      ],
      "id": "69fb1a4a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Compare RMSE across models\n",
        "\n",
        "-   Retrain the models on the training set only\n"
      ],
      "id": "16802439"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "formulas = ['price ~ points', \n",
        "            'price ~ points + bordeaux', \n",
        "            'price ~ points * bordeaux']\n",
        "ms = [smf.ols(f, data=train).fit() for f in formulas]"
      ],
      "id": "8d11264d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Test them all under the same conditions.\n"
      ],
      "id": "33b7d614"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def rmse(m):\n",
        "  residuals_sq = (test['price'] - m.predict(test)) ** 2\n",
        "  mse = np.mean(residuals_sq)\n",
        "  return mse ** .5\n",
        "\n",
        "[rmse(m) for m in ms]"
      ],
      "id": "41b9e15f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Exercise Problems\n",
        "\n",
        "-   *Bonus++. Pick a non-Bordeaux category.*\n",
        "    -   We write a quick reserve-checker and apply it.\n",
        "    -   Basically Python wasn't told all the data was textual\n",
        "        -   Use `str` and `lower`\n",
        "    -   Then use Pythonic `in` with a list of names\n",
        "-   `apply` is like `mutate`, in a way.\n"
      ],
      "id": "c803b0e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "is_reserve = lambda x: str(x).lower() in ['reserve','reserva','riserva']\n",
        "wine['reserve'] = wine['designation'].apply(is_reserve)"
      ],
      "id": "f3f79667",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## via Seaborn\n"
      ],
      "id": "ab252ae1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "sns.lmplot(wine, x='points', y='price', x_bins=range(80,101), hue='reserve',\n",
        "           x_estimator=np.mean, order=2) # polynomail regression, why not"
      ],
      "id": "fee079fd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Classification and Ethics\n",
        "\n",
        "## The math of it...\n",
        "\n",
        "-   This problem used a R library to get data.\n",
        "-   That R library is open source, \n",
        "    -   It has reasonable documentation, and\n",
        "    -   It's GitHub is linked from documentation.\n",
        "-   I spent 30 seconds on a search engine to find it.\n",
        "\n",
        "## Partition our Data\n",
        "-   The `.rda` file is at this url:\n",
        "    -   [https://github.com/rafalab/dslabs/blob/master/data/heights.rda](https://github.com/rafalab/dslabs/blob/master/data/heights.rda){style=\"font-size:smaller\"}\n",
        "    -   Change `blob` to `raw` to [download directly](https://github.com/rafalab/dslabs/raw/master/data/heights.rda).\n"
      ],
      "id": "759919f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "url = 'https://github.com/rafalab/dslabs/raw/master/data/'\n",
        "rds = 'heights.rda'\n",
        "pyreadr.download_file(url + rds, rds) \n",
        "heights = pyreadr.read_r(rds)['heights']      \n",
        "random_seed = 505\n",
        "train, test = train_test_split(heights, random_state=random_seed)"
      ],
      "id": "34a40162",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note: this vignette is adapted from [this book](https://rafalab.github.io/dsbook/introduction-to-machine-learning.html)\n",
        "\n",
        "## Guessing\n",
        "-   Let’s start by developing the simplest possible machine algorithm: guessing the outcome."
      ],
      "id": "b9e384e8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "y_hat = np.random.choice(['Male', 'Female'], len(test))"
      ],
      "id": "c09a01c4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Recall:\n",
        "\n",
        ">[Y hat (written ŷ ) is the predicted value of y (the dependent variable) in a regression equation. It can also be considered to be the average value of the response variable.](https://www.statisticshowto.com/y-hat-definition/)\n",
        "\n",
        "## Accuracy\n",
        "-   The overall accuracy is simply defined as the overall proportion that is predicted correctly:"
      ],
      "id": "68e982bf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.mean(y_hat == test['sex'])"
      ],
      "id": "46e997eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   What would we have expected the accuracy to be?\n",
        "    -   What much would we have expected accuracy to deviate from that expectionation?\n",
        "\n",
        "## Let's do better...\n"
      ],
      "id": "f0abd189"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "hs = heights.groupby('sex')['height']\n",
        "hs.std(), hs.mean()"
      ],
      "id": "125339e0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## A simple predictive model\n",
        "\n",
        "-   Idea: Predict `'Male'` if observation is within 2 standard deviations\n"
      ],
      "id": "5a616894"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "male_mean_less_2sd = hs.mean()['Male'] - 2*hs.std()['Male']\n",
        "\n",
        "y_hat = heights['height'].apply(lambda x : 'Male' if x > male_mean_less_2sd else 'Female')\n",
        "\n",
        "print(male_mean_less_2sd, np.mean(heights['sex'] == y_hat))"
      ],
      "id": "d3a73e5b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   The accuracy goes up from \\~0.50 to about \\~0.80!!\n",
        "\n",
        "## Let's optimize\n"
      ],
      "id": "bce29afd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cutoff = list(range(61,71))\n",
        "\n",
        "def get_accuracy(y):\n",
        "  f = lambda x : 'Male' if x > y else 'Female'\n",
        "  y_hat = heights['height'].apply(f)\n",
        "  return np.mean(heights['sex'] == y_hat)\n",
        "\n",
        "accuracy = list(map(get_accuracy, cutoff))\n",
        "\n",
        "accuracy"
      ],
      "id": "6f2f3490",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Optimal Cutoff\n"
      ],
      "id": "00c393e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "best_cutoff = cutoff[np.argmax(accuracy)]\n",
        "_ = plt.plot(cutoff, accuracy), print('Optimal cutoff is', best_cutoff)"
      ],
      "id": "932d012f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Should we be cutting at an integer?\n",
        "\n",
        "## Apply & Evaluate\n"
      ],
      "id": "80217243"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test['y_hat'] = test['height'].apply(lambda x : 'Male' if x > best_cutoff else 'Female')\n",
        "print('Accuracy is', np.mean(test['sex'] == test['y_hat']))"
      ],
      "id": "33eb7981",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Confusion matrix"
      ],
      "id": "f54f17d3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ConfusionMatrixDisplay.from_predictions(test['sex'], test['y_hat'])"
      ],
      "id": "ae0ba5a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "*Took 7 lines / 350+ characters of handwritten ggplot*\n",
        "\n",
        "## Accuracy by sex\n"
      ],
      "id": "f0548665"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test['acc'] = test['sex'] == test['y_hat']\n",
        "test.groupby('sex')['acc'].mean()"
      ],
      "id": "ce5fd1fe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "It's raining men.\n",
        "\n",
        "## Debrief\n",
        "\n",
        "\n",
        ":::: {.columns}\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "654b1820"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = sns.boxplot(heights, x='sex',y='height')"
      ],
      "id": "d736fb43",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.column width=\"50%\"}"
      ],
      "id": "c0c96d6b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_ = plt.pie(heights['sex'].value_counts(), labels=['♀','♂'])"
      ],
      "id": "6e484ee5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::::\n",
        "\n",
        "# Machine Learning in Python"
      ],
      "id": "673b0d0c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\cd-desk\\AppData\\Local\\Programs\\Python\\Python312\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}